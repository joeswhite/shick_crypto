#include <config.h>
#include <sodium.h>
#include <string.h>
#include <check.h>
#include "../src/shick_crypto.h"

const SC_CHAR alicesk[32] = {
 0xdd,0x93,0x5c,0xaf,0xc2,0x71,0x3d,0x07
,0x61,0x22,0xd3,0x5c,0x7b,0xf9,0x30,0x5f
,0x68,0x94,0x7f,0xfc,0x43,0xb5,0xb2,0x15
,0x64,0xc7,0x87,0xaf,0x03,0x7f,0x6b,0xc3
};

const SC_CHAR alicepk[32] = {
 0x83,0x0c,0x8e,0xc0,0x8d,0x2d,0x7b,0xb8
,0x98,0xc5,0x1c,0x59,0x41,0x97,0x32,0x97
,0x4e,0x58,0x7e,0x0e,0x08,0x5a,0x65,0x16
,0xd3,0x72,0xcb,0xf4,0xf4,0x18,0x09,0x54
};

const SC_CHAR bobsk[32] = {
 0x9c,0xbc,0x27,0x46,0x2c,0x58,0xf9,0x86
,0x75,0x98,0x2d,0x73,0x51,0xfc,0x6b,0x0f
,0xf3,0xd0,0x50,0x37,0x4b,0x4e,0x98,0x33
,0xe6,0xba,0x82,0x5d,0xa1,0x44,0x46,0xc4
};

const SC_CHAR bobpk[32] = {
 0x87,0xa1,0x69,0x56,0x60,0xcb,0x1d,0xaa
,0x4f,0x4a,0xb1,0x48,0x74,0x2c,0x66,0xe1
,0xee,0xc4,0x8a,0xef,0xe1,0xf2,0x66,0xbc
,0xdb,0x08,0x7a,0x88,0x36,0x4f,0x3a,0x0c
};

const SC_CHAR nonce[24] = {
 0x1f,0x5c,0xe1,0xf5,0x43,0x7d,0xb0,0x57
,0x53,0x6e,0x13,0x3f,0x55,0xf0,0x80,0x5e
,0x0e,0x75,0x11,0x5e,0xfe,0xbc,0x9f,0x67
};

const SC_CHAR enc_sym_key[72] = {
 0xf2,0x41,0x8d,0x22,0xce,0x24,0x1d,0x2c
,0x55,0x7a,0xd9,0xce,0xa1,0x8d,0xde,0x52
,0xf8,0xfb,0x35,0x7b,0x7a,0x07,0x9b,0x9c
,0xc9,0xc7,0x06,0xe9,0x54,0xaf,0x2f,0x72
,0x0c,0xd9,0x4e,0x3b,0x9f,0x90,0xe8,0x7d
,0xec,0x98,0xc2,0x4f,0x7c,0x3d,0x9e,0x37
,0xc9,0xce,0x54,0x9e,0x7f,0x82,0x96,0xc2
,0xd8,0xed,0xf5,0xd2,0xd3,0x08,0x30,0xb6
,0x18,0xdb,0xc3,0xea,0x92,0x8f,0xe8,0x31
};

const SC_CHAR message[] = "Shick Crypto Lib";

const SC_CHAR ciphertext[33] = {
 0xe5,0xa0,0xcc,0x0b,0xbf,0x84,0x66,0x39
,0x6e,0x60,0x07,0x25,0x83,0xb8,0x38,0x5f
,0xd1,0x14,0xe4,0x12,0x19,0xf7,0x84,0x68
,0x71,0x97,0x48,0x77,0x84,0xdb,0x9a,0x59
,0x46
};

START_TEST (test_shick_crypto_version) {
  const char* version = shick_crypto_version();
  ck_assert_str_eq (version, PACKAGE_VERSION);
}
END_TEST

START_TEST (test_shick_crypto_init) {
  shick_crypto_init();
}
END_TEST

START_TEST (test_shick_crypto_create_asymmetric_key_pair) {
  SC_CHAR secret_key[crypto_box_SECRETKEYBYTES];
  SC_CHAR public_key[crypto_box_PUBLICKEYBYTES];
  shick_crypto_init();

  int result = shick_crypto_create_asymmetric_key_pair(secret_key, public_key);

  ck_assert_int_eq (result, 0);
}
END_TEST

START_TEST (test_shick_crypto_create_nonce) {
  SC_CHAR zero[crypto_box_NONCEBYTES];
  bzero(zero, sizeof zero);
  SC_CHAR nonce[crypto_box_NONCEBYTES];
  bzero(nonce, sizeof zero);

  shick_create_nonce(nonce, sizeof nonce);

  int result = memcmp(nonce, zero, sizeof nonce);
  ck_assert_int_ne (result, 0);
}
END_TEST

START_TEST (test_shick_crypto_enc_messge) {
  int result = 0;
  SC_CHAR _nonce[crypto_box_NONCEBYTES];
  SC_CHAR encrypted_message[sizeof ciphertext];
  const SC_CHAR* recipient_public_keys[1];
  recipient_public_keys[0] = bobpk;
  SC_ENC_SYM_KEY encrypted_symmetric_keys[1];

  result = shick_crypto_enc_message(alicesk, recipient_public_keys, 1, message, sizeof message, _nonce, encrypted_symmetric_keys, encrypted_message);
  ck_assert_int_eq (result, 0);
}
END_TEST

START_TEST (test_shick_crypto_dec_messge) {
  int result = 0;
  SC_CHAR message_decrypted[sizeof message];

  result = shick_crypto_dec_message(bobsk, alicepk, *(SC_ENC_SYM_KEY*) &enc_sym_key, ciphertext, sizeof ciphertext, nonce, message_decrypted);
  ck_assert_int_eq (result, 0);
  ck_assert_str_eq((const char*) message_decrypted, (const char*) message);
}
END_TEST

Suite* shick_crypto_suite(void) {
  Suite *s = suite_create ("Shick Crypto Lib - Unit Tests");

  TCase *tc_core = tcase_create ("Core");
  tcase_add_test (tc_core, test_shick_crypto_version);
  tcase_add_test (tc_core, test_shick_crypto_init);
  tcase_add_test (tc_core, test_shick_crypto_create_asymmetric_key_pair);
  tcase_add_test (tc_core, test_shick_crypto_create_nonce);
  tcase_add_test (tc_core, test_shick_crypto_enc_messge);
  tcase_add_test (tc_core, test_shick_crypto_dec_messge);
  suite_add_tcase (s, tc_core);

  return s;
}

int main (void) {
  int number_failed;
  Suite *s = shick_crypto_suite();
  SRunner *sr = srunner_create(s);
  srunner_run_all(sr, CK_NORMAL);
  number_failed = srunner_ntests_failed(sr);
  srunner_free(sr);
  return (number_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
}

